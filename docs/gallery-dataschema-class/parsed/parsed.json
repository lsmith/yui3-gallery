{"majorversion": 3, "classmap": {"DataSchema": {"name": "DataSchema", "constructors": [{"params": [{"type": "Object", "name": "config", "description": "  object containing keys \"type\" and \"schema\""}], "description": "Abstract class encapsulation for any DataSchema implementation.  Pass the\nconstructor configuration an object containing these keys:\n<ul>\n<li><code>type</code> - \"json\", \"JSON\", Y.DataSchema.JSON, a custom\nimplementation object (must provide an apply method), or a custom\nfunction used as the apply method.</li>\n<li><code>schema</code> - the object containing the appropriate schema\nkey:values for the specified type of schema parser.  What you would\npass as the first argument to\nY.DataSchema.JSON.apply( SCHEMA, data );</li>\n</ul>\nThis class constructor replaces the Y.DataSchema object namespace.  All\nloaded schema parser implementations are preserved."}], "namespace": "", "module": "dataschema", "methods": {"_resolve": {"return": {"type": "Object", "description": "DataSchema parser implementation object"}, "description": "<p>Resolves the configured type to an implementation object (e.g.\nY.DataSchema.JSON).</p>\n<p>Accepts type as a string, object, or function.  Defalts to\nY.DataSchema.Base.</p>\n<p>If a string is supplied, an implementation is searched for as a\nstatic property of Y.DataSchema.  If one cannot be found, two more\nattempts are made with the string in upper case and then the string with\nfirst letter capitalized.</p>\n<p>If an object that contains a method named \"apply\" is passed, that\nobject is used.</p>\n<p>If a function is passed, that function is treated as the \"apply\"\nmethod of a Y.DataSchema.Base implementation.</p>", "protected": "", "params": [{"type": "Object|String|Function", "name": "type", "description": "  schema parser implemantation, its\nname, or a custom apply function to use over Base implementation"}], "guessedname": "_resolve", "guessedtype": "function"}, "_init": {"protected": "", "params": [{"type": "Object", "name": "config", "description": "  object passed in from constructor"}], "description": "Initialize the instance, resolve the configured schema parser\nimplementation, and add any other properties or custom methods onto this\nobject.  Generally, the \"any other properties\" should be just the\nschema.", "guessedname": "_init", "guessedtype": "function"}, "apply": {"return": {"type": "Object", "description": "Schema-parsed data"}, "params": [{"type": "mixed", "name": "data", "description": "  input data to be parsed by the schema implementation"}], "description": "Pass the data to the schema parser implementation with the configured\nschema.", "guessedname": "apply", "guessedtype": "function"}}, "file": "L", "shortname": "DataSchema", "description": "Abstract class encapsulation for any DataSchema implementation.  Pass the\nconstructor configuration an object containing these keys:\n<ul>\n<li><code>type</code> - \"json\", \"JSON\", Y.DataSchema.JSON, a custom\nimplementation object (must provide an apply method), or a custom\nfunction used as the apply method.</li>\n<li><code>schema</code> - the object containing the appropriate schema\nkey:values for the specified type of schema parser.  What you would\npass as the first argument to\nY.DataSchema.JSON.apply( SCHEMA, data );</li>\n</ul>\nThis class constructor replaces the Y.DataSchema object namespace.  All\nloaded schema parser implementations are preserved."}}, "version": "3", "modules": {"dataschema": {"classlist": ["DataSchema"], "subdata": {"dataschema-class": {"name": "DataSchema", "description": "Abstract class encapsulation for any DataSchema implementation.  Pass the\nconstructor configuration an object containing these keys:\n<ul>\n<li><code>type</code> - \"json\", \"JSON\", Y.DataSchema.JSON, a custom\nimplementation object (must provide an apply method), or a custom\nfunction used as the apply method.</li>\n<li><code>schema</code> - the object containing the appropriate schema\nkey:values for the specified type of schema parser.  What you would\npass as the first argument to\nY.DataSchema.JSON.apply( SCHEMA, data );</li>\n</ul>\nThis class constructor replaces the Y.DataSchema object namespace.  All\nloaded schema parser implementations are preserved."}}, "name": "dataschema", "filelist": ["dataschema-class.js"], "submodules": ["dataschema-class"]}}, "filemap": {"dataschema-class.js": {"name": "dataschema-class.js", "classlist": [], "module": "dataschema", "guessedname": "L", "guessedtype": "property", "property": "L"}}}