<div class="highlight" ><pre><span class="k">var</span> <span class="nx">L</span> <span class="o">=</span> <span class="nx">Y</span><span class="o">.</span><span class="nx">Lang</span><span class="o">,</span>
    <span class="nx">isFunction</span> <span class="o">=</span> <span class="nx">L</span><span class="o">.</span><span class="nx">isFunction</span><span class="o">,</span>
    <span class="nx">isObject</span>   <span class="o">=</span> <span class="nx">L</span><span class="o">.</span><span class="nx">isObject</span><span class="o">;</span>

<span class="c">/**</span>
<span class="c"> * Abstract class encapsulation for any DataSchema implementation.  Pass the</span>
<span class="c"> * constructor configuration an object containing these keys:</span>
<span class="c"> *</span>
<span class="c"> * &lt;ul&gt;</span>
<span class="c"> *   &lt;li&gt;&lt;code&gt;type&lt;/code&gt; - &quot;json&quot;, &quot;JSON&quot;, Y.DataSchema.JSON, a custom</span>
<span class="c"> *       implementation object (must provide an apply method), or a custom</span>
<span class="c"> *       function used as the apply method.&lt;/li&gt;</span>
<span class="c"> *   &lt;li&gt;&lt;code&gt;schema&lt;/code&gt; - the object containing the appropriate schema</span>
<span class="c"> *       key:values for the specified type of schema parser.  What you would</span>
<span class="c"> *       pass as the first argument to</span>
<span class="c"> *       Y.DataSchema.JSON.apply( SCHEMA, data );&lt;/li&gt;</span>
<span class="c"> * &lt;/ul&gt;</span>
<span class="c"> *</span>
<span class="c"> * This class constructor replaces the Y.DataSchema object namespace.  All</span>
<span class="c"> * loaded schema parser implementations are preserved.</span>
<span class="c"> *</span>
<span class="c"> * @module dataschema</span>
<span class="c"> * @submodule dataschema-class</span>
<span class="c"> * @class DataSchema</span>
<span class="c"> * @constructor</span>
<span class="c"> * @param config {Object} object containing keys &quot;type&quot; and &quot;schema&quot;</span>
<span class="c"> */</span>
<span class="k">function</span> <span class="nx">DataSchema</span><span class="o">(</span><span class="nx">config</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="nx">_init</span><span class="o">(</span><span class="nx">config</span><span class="o">);</span>
<span class="o">}</span>

<span class="nx">DataSchema</span><span class="o">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c">/**</span>
<span class="c">     * Initialize the instance, resolve the configured schema parser</span>
<span class="c">     * implementation, and add any other properties or custom methods onto this</span>
<span class="c">     * object.  Generally, the &quot;any other properties&quot; should be just the</span>
<span class="c">     * schema.</span>
<span class="c">     *</span>
<span class="c">     * @method _init</span>
<span class="c">     * @param config {Object} object passed in from constructor</span>
<span class="c">     * @protected</span>
<span class="c">     */</span>
    <span class="nx">_init</span><span class="o">:</span> <span class="k">function</span> <span class="o">(</span><span class="nx">config</span><span class="o">)</span> <span class="o">{</span>
        <span class="nx">config</span> <span class="o">=</span> <span class="nx">isObject</span><span class="o">(</span><span class="nx">config</span><span class="o">)</span> <span class="o">?</span> <span class="nx">config</span> <span class="o">:</span> <span class="o">{};</span>

        <span class="nx">Y</span><span class="o">.</span><span class="nx">mix</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="nx">config</span><span class="o">);</span>

        <span class="k">this</span><span class="o">.</span><span class="nx">_impl</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="nx">_resolve</span><span class="o">(</span><span class="nx">config</span><span class="o">.</span><span class="nx">type</span> <span class="o">||</span> <span class="s1">&#39;Base&#39;</span><span class="o">);</span>
    <span class="o">},</span>

    <span class="c">/**</span>
<span class="c">     * &lt;p&gt;Resolves the configured type to an implementation object (e.g.</span>
<span class="c">     * Y.DataSchema.JSON).&lt;/p&gt;</span>
<span class="c">     *</span>
<span class="c">     * &lt;p&gt;Accepts type as a string, object, or function.  Defalts to</span>
<span class="c">     * Y.DataSchema.Base.&lt;/p&gt;</span>
<span class="c">     *</span>
<span class="c">     * &lt;p&gt;If a string is supplied, an implementation is searched for as a</span>
<span class="c">     * static property of Y.DataSchema.  If one cannot be found, two more</span>
<span class="c">     * attempts are made with the string in upper case and then the string with</span>
<span class="c">     * first letter capitalized.&lt;/p&gt;</span>
<span class="c">     *</span>
<span class="c">     * &lt;p&gt;If an object that contains a method named &quot;apply&quot; is passed, that</span>
<span class="c">     * object is used.&lt;/p&gt;</span>
<span class="c">     *</span>
<span class="c">     * &lt;p&gt;If a function is passed, that function is treated as the &quot;apply&quot;</span>
<span class="c">     * method of a Y.DataSchema.Base implementation.&lt;/p&gt;</span>
<span class="c">     *</span>
<span class="c">     * @method _resolve</span>
<span class="c">     * @param type {Object|String|Function} schema parser implemantation, its</span>
<span class="c">     *  name, or a custom apply function to use over Base implementation</span>
<span class="c">     * @return {Object} DataSchema parser implementation object</span>
<span class="c">     * @protected</span>
<span class="c">     */</span>
    <span class="nx">_resolve</span><span class="o">:</span> <span class="k">function</span> <span class="o">(</span><span class="nx">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">var</span> <span class="nx">impl</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="nx">L</span><span class="o">.</span><span class="nx">isString</span><span class="o">(</span><span class="nx">type</span><span class="o">))</span> <span class="o">{</span>
            <span class="c">// Tries e.g. DataSchema.json, DataSchema.JSON, then DataSchema.Json</span>
<span class="c"></span>            <span class="nx">impl</span> <span class="o">=</span> <span class="nx">DataSchema</span><span class="o">[</span><span class="nx">type</span><span class="o">]</span> <span class="o">||</span> <span class="nx">DataSchema</span><span class="o">[</span><span class="nx">type</span><span class="o">.</span><span class="nx">toUpperCase</span><span class="o">()]</span> <span class="o">||</span>
                   <span class="nx">DataSchema</span><span class="o">[</span><span class="nx">type</span><span class="o">.</span><span class="nx">charAt</span><span class="o">(</span><span class="m">0</span><span class="o">).</span><span class="nx">toUpperCase</span><span class="o">()</span> <span class="o">+</span> <span class="nx">type</span><span class="o">.</span><span class="nx">slice</span><span class="o">(</span><span class="m">1</span><span class="o">)];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="nx">isFunction</span><span class="o">(</span><span class="nx">type</span><span class="o">))</span> <span class="o">{</span>
            <span class="nx">impl</span> <span class="o">=</span> <span class="nx">Y</span><span class="o">.</span><span class="nb">Object</span><span class="o">(</span><span class="nx">DataSchema</span><span class="o">.</span><span class="nx">Base</span><span class="o">);</span>
            <span class="nx">impl</span><span class="o">.</span><span class="nx">apply</span> <span class="o">=</span> <span class="nx">type</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="nx">isObject</span><span class="o">(</span><span class="nx">type</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isFunction</span><span class="o">(</span><span class="nx">type</span><span class="o">.</span><span class="nx">apply</span><span class="o">))</span> <span class="o">{</span>
            <span class="nx">impl</span> <span class="o">=</span> <span class="nx">type</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(!</span><span class="nx">impl</span><span class="o">)</span> <span class="o">{</span>
            <span class="nx">Y</span><span class="o">.</span><span class="nx">log</span><span class="o">(</span><span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot; DataSchema not found. Defaulting to Base&quot;</span><span class="o">,</span> <span class="s2">&quot;warn&quot;</span><span class="o">,</span> <span class="s2">&quot;dataSchema&quot;</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="nx">impl</span> <span class="o">||</span> <span class="nx">DataSchema</span><span class="o">.</span><span class="nx">Base</span><span class="o">;</span>
    <span class="o">},</span>

    <span class="c">/**</span>
<span class="c">     * Pass the data to the schema parser implementation with the configured</span>
<span class="c">     * schema.</span>
<span class="c">     *</span>
<span class="c">     * @method apply</span>
<span class="c">     * @param data {mixed} input data to be parsed by the schema implementation</span>
<span class="c">     * @return {Object} Schema-parsed data</span>
<span class="c">     */</span>
    <span class="nx">apply</span><span class="o">:</span> <span class="k">function</span> <span class="o">(</span><span class="nx">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">Y</span><span class="o">.</span><span class="nb">Array</span><span class="o">(</span><span class="nx">arguments</span><span class="o">,</span><span class="m">0</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
        <span class="nx">args</span><span class="o">.</span><span class="nx">unshift</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="nx">schema</span><span class="o">);</span>

        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="nx">_impl</span><span class="o">.</span><span class="nx">apply</span><span class="o">.</span><span class="nx">apply</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="nx">_impl</span><span class="o">,</span> <span class="nx">args</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">};</span>

<span class="c">// Replace the object namespace with the constructor, migrating all</span>
<span class="c">// schema implementations to static properties.</span>
<span class="c"></span><span class="nx">Y</span><span class="o">.</span><span class="nx">DataSchema</span> <span class="o">=</span> <span class="nx">Y</span><span class="o">.</span><span class="nx">mix</span><span class="o">(</span><span class="nx">DataSchema</span><span class="o">,</span> <span class="nx">Y</span><span class="o">.</span><span class="nx">DataSchema</span><span class="o">);</span>
</pre></div>
